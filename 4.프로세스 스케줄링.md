# 프로세스 스케줄링

#### 4.1 멀티태스킹

- 하나 이상의 프로세스를 동시에 중첩 형태로 실행할 수 있는 운영체제
- 종류: 협동형 멀티태스킹(cooperative multitasking), 선점형 멀티태스킹(preemptive multitasking)
- 선점형 멀티태스킹(preemptive multitasking)
  - 리눅스, 유닉스에서 사용
  - 프로세스 실행을 언제 중단하고 다른 프로세스를 실행할지를 스케줄러가 결정
  - 선점: 실행 중인 프로세스를 강제로 중지시키는 작업
  - 타임슬라이스: 프로세스가 선점되기 전까지 프로세스에 주어지는 시간
- 협동형 멀티태스킹(cooperative multitasking)
  - 프로세스가 자발적으로 실행을 중단
  - 양보(yield): 프로세스가 자발적으로 동작을 중단하는 행동
  - 단점이 명확 => 대부분 운영체제에서는 선점형 멀티태스킹을 지원



#### 4.2 리눅스의 프로세스 스케줄러

- 회전 계단식 기한 스케줄러(Roatating Staircase Deadline Scheduler)
- CFS



#### 4.3 정책

- 정책(policy): 스케줄러가 무엇을 언제 실행할 것인지를 정하는 동작
- 입출력중심 프로세스
  - 입출력 요청을 하고 기다리는데 대부분의 시간을 사용하는 프로세스
  - 입출력을 기다리는 작업을 반복
  - 실제 실행시간은 아주 짧다.
- 프로세서 중심 프로세스
  - 대부분의 시간을 코드를 실행하는데 사용
  - 선점될때까지 계속 실행
  - 좀 더 긴 시간 동안, 덜 자주 실행하는 스케줄러 정책이 좋음
- 시스템 스케줄링 정책의 목적
  - 프로세스 응답시간을 빠르게 하는 것 (낮은 지연시간)
  - 시스템 사용률을 최대화하는 것 (산출물 극대화)
- 프로세스 우선순위
  - 가치와 필요에 따라 프로세스의 순위를 매겨 프로세서 시간을 할당
  - 일반적) 우선순위가 높은 프로세스를 우선순위가 낮은 프로세스보다 먼저 실행하고, 우선순위가 같은면 순환방식(round-robbin)으로 실행
  - 리눅스 커널
    - 나이스 값
      - -20 ~ + 19
      - 기본 값: 0
      - 나이스 값이 클수록 우선순위가 낮다
      - 나이스 값이 낮은 프로세스는 나이스 값이 높은 프로세스보다 더 많은 시스템 프로세서 사용기간을 할당
      - $ps -el로 확인 가능
    - 실시간 우선순위
      - 0~99
      - 값이 클수록 우선순위가 높다.
      - 실시간 프로세스는 일반적인 프로세스보다 우선순위가 높다.
      - 실시간 우선순위 값은 나이스 값과는 별도의 값이다.
      - $ps -eo state, uid, pid, ppid, trprio, time, comm
- 타임 슬라이스
  - 타임 슬라이스: 선점되기 전까지 작업을 얼마나 더 실행할 수 있는지 나타내는 값



#### 4.4 리눅스 스케줄링 알고리즘

- 스케줄러 클래스
  - 모듈화 => 스케줄러 클래스
- 유닉스 시스템의 프로세스 스케줄링
  - 문제
    - 나이스 값과 타임슬라이스를 연계시키려면 각 나이스 값에 할당할 타임슬라이스의 절대값을 정할 수 밖에 없다.
    - 나이스 값이 타임슬라이스와 묶이는 것과 나이스 값의 상대적인 차이에 따라 발생한다.
    - 나이스 값에 따라 타임슬라이스를 할당하려면 타임슬라이스의 절대값을 할당할 수 있어야한다.
    - 우선순위 기반 스케줄러가 대화형 작업을 최적화하고자 할 경우에 프로세스 깨우기 처리와 관련된 문제가 존재한다.
- 공정 스케줄링
  - 실행 가능한 프로세스가 n개 있을 경우 => 각 프로세스에 1/n의 프로세스 시간을 할당
  - 실행 가능한 전체 프로세스 개수와 관련된 함수를 이용해 프로세스를 얼마동안 실행해야 하는지 계산



#### 4.5 리눅스 스케줄링 구현

- kernel/sched_fair.c
- CFS 4가지 구성 요소
  - 시간 기록
  - 프로세스 선택
  - 스케줄러 진입 위치
  - 휴면 및 깨어남



#### 4.6 선점과 컨텍스트 전환

- 컨텍스트 전환 (context switching)
  - kernel/sched.c => context_switch()
  - 실행중인 한 작업에서 다른 작업으로 전환
- 사용자 선점
  - 커널이 사용자 공간으로 돌아가는 순간 need_resched 플래그가 설정되어 있어 스케줄러가 호출되면서 발생
  - 시스템 호출에서 사용자 공간으로 돌아갈 때
  - 인터럽트 처리를 끝내고 사용자 공간으로 돌아갈 때
- 커널 선점
  - 리눅스 커널은 완벽한 선점형 커널이다.
  - 스케줄링을 다시해도 안전한 상태이기만하면 언제든지 선점 가능
  - 실행중인 작업이 잠금을 설정하고 있지 않은 상태
  - thread_info의 preempt_count값이 0일때 선점 가능
  - 명시적 선점
    - 커널의 상태가 대기상태가 되어 중단
    - schedule() 함수를 직접 호출
  - 커널 선점이 발생하는 경우
    - 인터럽트 처리를 마치고 커널 공간으로 돌아갈 때
    - 커널 코드가 다시 선점 가능한 상태가 되었을 때
    - 커널 내부 작업이 명시적으로 schedule()함수를 호출하는 경우
    - 커널 내부 작업이 중단되어 대시 상태가 되는, 그래서 결국 schedule()함수를 호출하게 되는 경우



#### 4.7 실시간 스케줄링 정책

- SCHED_FIFO, SCHED_RR: 실시간 스케줄링 정책
- kernel/sched_rt.c에 정의된 별도의 특별한 스케줄러를 이용
- SCHED_FIFO
  - 선입선출 구조의 스케줄링 알고리즘
  - SCHED_NORMAL 클래스의 작업보다 항상 우선 실행
  - 타임 슬라이스를 별도로 할당하지 않는다.
  - 해당 작업이 중단되거나 자발적으로 프로세서를 양보하지 않는 한 계속 실햏ㅇ
  - 우선 순위가 더 높은 SCHED_FIFO작업이나 SCHED_RR작업만이 선점 가능
- SCHED_RR
  - 타임 슬라이스가 있는 SCHED_FIFO
  - 실시간 순차 실행 스케줄링 알고리즘
- 부드러운 실시간 동작 (soft real-time behavior)
  - 커널이 일정한 기한 안에서 애플리케이션을 스케줄링하려고 노력하지만 항상 그렇게 된다는 것을 보장하지 않는다.
- 엄격한 실시간 동작 (hard real-time behavior)
  - 시스템은 항상 주어진 기한 내에 모든 스케줄링 요구사항을 만족하는 시스템



#### 4.8 스케줄러 관련 시스템 호출

| 시스템 호출              | 설명                                        |
| ------------------------ | ------------------------------------------- |
| nice()                   | 프로세스의 나이스 값을 설정한다.            |
| sched_setscheduler()     | 프로세스의 스케줄링 정책을 설정한다.        |
| sched_getscheduler()     | 프로세스의 스케줄링 정책을 가져온다.        |
| sched_setparam()         | 프로세스의 실시간 우선순위를 설정한다.      |
| sched_getparam()         | 프로세스의 실시간 우선순위를 가져온다.      |
| sched_get_priority_max() | 실시간 우선순위의 최대값을 가져온다.        |
| sched_get_priority_min() | 실시간 우선순위의 최소값을 가져온다.        |
| sched_rr_get_interval()  | 프로세스의 타임슬라이스 값을 가져온다.      |
| sched_setaffinity()      | 프로세스의 프로세서 지속성 정보를 설정한다. |
| sched_getaffinity()      | 프로세스의 프로세서 지속성 정보를 가져온다. |
| sched_yield()            | 일시적으로 프로세서를 양보한다.             |

