# 커널 자료구조

#### 6.1 연결 리스트

- 리눅스 커널에서 가장 많이 사용하는 가장 간단한 자료구조

- 노드: 가변적인 개수의 데이터

- 동적으로 데이터를 생성해 리스트에 추가할 수 있다.

- 컴파일 시점에 미리 개수를 알 수 없는 데이터를 관리할 수 있다.

- 단순 연결 리스트

  ``` c
  struct list_element{
      void *data;					/* 항목에 담긴 데이터 (payload) */
      struct list_element *next; 	/* 다음 항목을 가리키는 포인터 */
  }
  ```

- 이중 연결 리스트

  ``` c
  struct list_element{
      void *data;					/* 항목에 담긴 데이터 (payload) */
      struct list_element *next; 	/* 다음 항목을 가리키는 포인터 */
      struct list_element *prev;	/* 이전 항목을 가리키는 포인터 */
  }
  ```

- 환형 연결 리스트

  - 마지막 노드가 리스트의 처음 항목을 가리킨다.

- 연결 리스트 내에서 이동

  - 선형으로 일어남
  - 한 항목을 참조하고, 다음 포인터를 따라가 다음 항목을 참조
  - head: 리스트의 첫 번째 항목

- 리눅스 커널의 구현 방식

  - <linux/list.h>

  ``` C
  struct list_head {
      struct list_head *next;
      struct list_head *prev;
  }
  ```

  - 보통 다른 구조체 안에 넣어서 사용
  - 리스트는 사용하기 전에 초기화   **INIT_LIST_HEAD()**

-  연결 리스트 조작

  - 연결 리스트에 노드 추가

  ``` C
  list_add(struct list_head *new, struct list_head *head);
  list_add_tail(struct list_head *new, struct list_head *head);
  ```

  - 연결 리스트에서 노드 제거

  ``` C
  list_del(struct list_head *entry);
  list_del_init(struct list_head *entry);
  ```

  - 연결 리스트의 노드 이동과 병합
  
  ``` c
  list_move(struct list_head *list, struct list_head *head);
  list_move_tail(struct list_head *list, struct list_head *head);
  list_empty(struct list_head *head);
  list_splice(struct list_head *list, struct list_head *head);
  list_splice_init(struct list_head *list, struct list_head *head);
  ```

- 연결 리스트 탐색

  - 기본 방법

    - list_for_each() 매크로 : 첫번째 인자는 현재 항목을 가리키는 포인터, 두번째 인자는 탐색하려는 리스트의 헤드 역할을 하는 list_head를 가리키는 포인터

    ``` c
    struct list_head *p;
    struct fox *f;
    
    list_for_each(p, &fox_list){
        /* f는 리스트가 들어 있는 구조체를 가리킨다. */
        f = list_entry(p, struct fox, list);
    }
    ```

  - 실제 사용하는 방식

    - list_for_each_entry(pos, head, member)

    ``` c
    static struct inotify_watch *inode_find_handle(struct inode *inode, struct inotify_handle *ih){
        struct inotify_watch *watch;
        
        list_for_each_entry(watch, &inode->inotify_watches, i_list){
            if(watch->ih ==ih)
                return watch;
        }
        return NULL;
    }
    ```

  - 역방향으로 리스트 탐색

    - list_for_each_entry_reverse(pos, head, member)

  - 제거하면서 탐색

    - list_for_each_entry_safe(pos, next, head, member)

    ``` c
    void inotify_inode_is_dead(struct inode *inode){
        struct inotify_watch *wathc, *next;
        
        mutex_lock(&inode->inotify_mutex);
        list_for_each_entry_safe(watch, next, &inode->inotify_watches, i_list){
            struct inotify_handle *ih = watch->ih;
            mutext_lock(&ih->mutex);
            inotify_remove_watch_locked(ih, watch);	/* watch를 제거 */
            mutex_unlock(&ih->mutex);
        }
        mutex_unlock(&inode->inotify_mutex);
    }
    ```



