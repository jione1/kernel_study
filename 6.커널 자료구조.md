# 커널 자료구조

#### 6.1 연결 리스트

- 리눅스 커널에서 가장 많이 사용하는 가장 간단한 자료구조

- 노드: 가변적인 개수의 데이터

- 동적으로 데이터를 생성해 리스트에 추가할 수 있다.

- 컴파일 시점에 미리 개수를 알 수 없는 데이터를 관리할 수 있다.

- 단순 연결 리스트

  ``` c
  struct list_element{
      void *data;					/* 항목에 담긴 데이터 (payload) */
      struct list_element *next; 	/* 다음 항목을 가리키는 포인터 */
  }
  ```

- 이중 연결 리스트

  ``` c
  struct list_element{
      void *data;					/* 항목에 담긴 데이터 (payload) */
      struct list_element *next; 	/* 다음 항목을 가리키는 포인터 */
      struct list_element *prev;	/* 이전 항목을 가리키는 포인터 */
  }
  ```

- 환형 연결 리스트

  - 마지막 노드가 리스트의 처음 항목을 가리킨다.

- 연결 리스트 내에서 이동

  - 선형으로 일어남
  - 한 항목을 참조하고, 다음 포인터를 따라가 다음 항목을 참조
  - head: 리스트의 첫 번째 항목

- 리눅스 커널의 구현 방식

  - <linux/list.h>

  ``` C
  struct list_head {
      struct list_head *next;
      struct list_head *prev;
  }
  ```

  - 보통 다른 구조체 안에 넣어서 사용
  - 리스트는 사용하기 전에 초기화   **INIT_LIST_HEAD()**

-  연결 리스트 조작

  - 연결 리스트에 노드 추가

  ``` C
  list_add(struct list_head *new, struct list_head *head);
  list_add_tail(struct list_head *new, struct list_head *head);
  ```

  - 연결 리스트에서 노드 제거

  ``` C
  list_del(struct list_head *entry);
  list_del_init(struct list_head *entry);
  ```

  - 연결 리스트의 노드 이동과 병합
  
  ``` c
  list_move(struct list_head *list, struct list_head *head);
  list_move_tail(struct list_head *list, struct list_head *head);
  list_empty(struct list_head *head);
  list_splice(struct list_head *list, struct list_head *head);
  list_splice_init(struct list_head *list, struct list_head *head);
  ```

- 연결 리스트 탐색

  - 기본 방법

    - list_for_each() 매크로 : 첫번째 인자는 현재 항목을 가리키는 포인터, 두번째 인자는 탐색하려는 리스트의 헤드 역할을 하는 list_head를 가리키는 포인터

    ``` c
    struct list_head *p;
    struct fox *f;
    
    list_for_each(p, &fox_list){
        /* f는 리스트가 들어 있는 구조체를 가리킨다. */
        f = list_entry(p, struct fox, list);
    }
    ```

  - 실제 사용하는 방식

    - list_for_each_entry(pos, head, member)

    ``` c
    static struct inotify_watch *inode_find_handle(struct inode *inode, struct inotify_handle *ih){
        struct inotify_watch *watch;
        
        list_for_each_entry(watch, &inode->inotify_watches, i_list){
            if(watch->ih ==ih)
                return watch;
        }
        return NULL;
    }
    ```

  - 역방향으로 리스트 탐색

    - list_for_each_entry_reverse(pos, head, member)

  - 제거하면서 탐색

    - list_for_each_entry_safe(pos, next, head, member)

    ``` c
    void inotify_inode_is_dead(struct inode *inode){
        struct inotify_watch *wathc, *next;
        
        mutex_lock(&inode->inotify_mutex);
        list_for_each_entry_safe(watch, next, &inode->inotify_watches, i_list){
            struct inotify_handle *ih = watch->ih;
            mutext_lock(&ih->mutex);
            inotify_remove_watch_locked(ih, watch);	/* watch를 제거 */
            mutex_unlock(&ih->mutex);
        }
        mutex_unlock(&inode->inotify_mutex);
    }
    ```



#### 6.2 큐

- 특징
  - 생산자와 소비자 모델 (producer and consumer model)
    - 생산자는 처리가 필요한 오류 메시지나 네트워크 패킷 같은 데이터를 만들어내고 소비자는 메시지를 읽거나 패킷을 처리하는 등의 작업으로 데이터를 소비한다.
    - 생산자는 큐에 데이터를 집어 넣고, 소비자는 큐에 데이터를 꺼내쓴다.
  - 선입 선출 FIFO(first-in, first-out)
  - <linux/kfifo.h>

![](C:\Users\user\Desktop\kernel_study\images\6_1.png)

- kfifo
  - enqueue, dequeue
- 큐 생성
  - int kfifo_alloc(struct kfifo *fifo, unsigned int size, gfp_t gfp_mask)
    - 크가기 size 바이트인 kfifo 큐를 생성하고 초기화
  - void kfifo_init(struct kfifo *fifo, void *buffer, unsigned int size);
    - 크기가 size 바이트인 buffer가 가리키는 공간을 사용하는 kfifo를 생성하고 초기화
- 큐에 데이터 넣기
  - unsigned int kfifo_in(struct kfifo *fifo, const void *from, unsigned int len);
    - from이 가리키는 위치부터 len 바이트만큼의 데이터를 fifo 큐에 넣는다
- 큐에서 데이터 빼기
  - unsigned int kfifo_out(struct kfifo *fifo, void *to, unsigned int len);
    - 큐에서 최대 len 바이트 만큼의 데이터를 to가 가리키는 버퍼에 복사
    - 큐에서 데이터를 빼면 해당 데이터는 더 이상 큐에 접근 불가
  - unsignd int kfifo_out_peek(struct kfifo *fifo, void *to, unsigned int len, unsigned offset);
    - 데이터를 제거하지 않고 '들여다 보기'
- 큐의 크기 알아내기
  - static inline unsigned int kfifo_size(struct kfifo *fifo);
  - static inline unsigned int kfifo_len(struct kfifo *fifo);
  - static inline unsigned int kfifo_avail(struct kfifo *fifo);
  - static inline int kfifo_is_empty(struct kfifo *fifo);
  - static inline int kfifo_is_full(struct kfifo *fifo);
- 큐 재설정과 큐 삭제
  - static inline void kfifo_reset(struct kfifo *fifo);
  - void kfifo_free(struct kfifo *fifo);

